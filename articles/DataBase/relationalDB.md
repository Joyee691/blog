# 关系型数据库

## 关系相关定义

- 域（Domain）：一组具有相同数据类型的值的集合
- 笛卡尔积（Cartesian product）：所有域的所有取值的集合
- 元组（Tuple）：笛卡尔积中每个元素被称为元组
- 分量（Component）：笛卡尔积元素中的每个值被称为分量
- 基数（Cardinal number）：一个域中能够取值的数量，笛卡尔积之后的基数是原来域基数的乘积

## 关系中的码

- 候选码（Candidate key）：关系中能唯一标识一个元组的属性组，属性组可能包含一个或多个属性
- 全码（All-key）：关系中所有属性的集合是候选码
- 主码（Key）：从多个候选码中择一为主码
- 主属性：候选码的属性
- 非主属性：除了主属性之外的属性

## 三类关系

- 基本关系（基表）：实际存储的表
- 查询表：查询结果对应的表
- 视图表：由基本表或其他视图表导出的表，不对应实际存储的数据

## 关系基本性质

- 不同的列可能出自同一个域，每一列代表一个属性，不同属性要有不同名字
- 列与行的顺序无所谓
- 任意两个元组候选码必须相同
- 所有分量（列）必须都是原子值

## 关系代数

关系代数是一种抽象查询语言，是关系运算来表达查询

关系代数运算对象是关系，运算结果也是关系

关系代数根据运算符可以分为**集合运算**与**专门的关系运算**两类

集合运算只从关系的**水平方向**进行，是行的运算

关系运算包含关系的**行与列**

## 关系运算符

![db-1](https://raw.githubusercontent.com/Joyee691/image-hosting/main/blog/db-1.jpeg)

### 并 Union

并的运算符是 $\bigcup$

它的含义是 **n 目关系中，元组 R 跟 S 的去重合并**

举个例子：

R 跟 S 都是三目关系，R = {[1, 2, 3], [1, 2, 4]} ，S = {[1, 2, 4], [1, 2, 5]}

R $\bigcup$ S = {[1, 2, 3], [1, 2, 4], [1, 2, 5]}

可以看到，通过并运算，R 跟 S 中重复的元素 [1, 2, 4] 只出现了一次

### 差 Except

差的运算符是 $-$

它的含义是 **n 目关系中，属于 R 但不属于 S 的所有元组**

举个例子：

有两个三目关系，R = {[1, 2, 3], [1, 2, 4]} ，S = {[1, 2, 4], [1, 2, 5]}

R - S = {[1, 2, 3]}

通过差运算，我们可以去除掉关系中的某部分元组

### 交 Intersection

交的运算符是 $\bigcap$

它的含义是 **n 目关系中，属于 R 且属于 S 的元组**

举个例子：

R 跟 S 都是三目关系，R = {[1, 2, 3], [1, 2, 4]} ，S = {[1, 2, 4], [1, 2, 5]}

R $\bigcap$ S = {[1, 2, 4]}

通过交运算，我们可以找到两个关系中共有的元组

### 笛卡尔积 Cartesian Product

笛卡尔积的运算符是 $\times$

它的含义是**一对 m 目关系与 n 目关系的乘积**

举个例子：

R 是 1 目关系，R = {[1], [2]}；S 是 2 目关系，S = {[3, 4]}

R $\times$ S = {[1, 3, 4], [2, 3, 4]}

通过笛卡尔积运算的结果会有 m+n 列，m*n 行

### 选择 Selection

选择的运算符是 $\sigma$

它用于**在一个关系中选择满足给定条件的元组**

表示方法为：$\sigma_{F}(R)$，其中 R 代表一个关系

其中下标的 F 是一个选择条件，它的基本形式为 $X_1 \theta Y_1$

$\theta$ 表示比较运算符，可以是大于、大于等于、小于、小于等于、等于……

X1，Y1 是属性名、常量，或简单函数

举个例子：

想要筛选出关系 R 中属性 x 为 true 的元组，我们可以用

$\sigma_{x = true}(R)$ 来表示

### 投影

投影的运算符是 $\pi$

用于**从关系中选出若干属性列组成新的关系**

表示方法为：$\pi_{A}(R)$，其中 R 表示一个关系，A 表示 R 中的属性列

投影的结果如果有两个重复的行，会执行去重操作

### 连接 Join

连接又被称为 $\theta$ 连接，表示**从两个关系的笛卡尔积中选取属性满足一定条件的元组**

连接的运算符是 $\bowtie$

表示方法为：$R \mathop{\bowtie}\limits_{A\theta B}S$

其中 R 跟 S 是两个关系，$\theta$ 表示比较运算符，A 与 B 表示属性名、常量，或简单函数

<br />

有两种特殊的连接：

- **等值连接**
  
    表示为 $R \mathop{\bowtie}\limits_{A = B}S$
    
    等值连接就是当比较运算符为等于时的连接
    
- **自然连接**
  
    表示为 $R \bowtie S$
    
    自然连接就是当 A 与 B 为同一个属性的等值连接（需要去重）
    
- 外连接
  
    外连接是指将不符合条件的关系数据也记录进来，没有数据的部分就置空
    
- 左外连接与右外连接
  
    左外连接指的是在外连接的基础上只保留左边关系的数据；右外连接指的是在外连接的基础上只保留右边关系的数据
    

<br />

举个例子：

关系 R

| A | B | C |
| --- | --- | --- |
| a1 | b1 | 5 |
| a1 | b2 | 6 |
| a2 | b3 | 8 |
| a2 | b4 | 12 |

关系 S

| B | E |
| --- | --- |
| b1 | 3 |
| b2 | 7 |
| b3 | 10 |
| b3 | 2 |
| b5 | 2 |

普通连接：$R \mathop{\bowtie}\limits_{C \lt E}S$

| A | R.B | C | S.B | E |
| --- | --- | --- | --- | --- |
| a1 | b1 | 5 | b2 | 7 |
| a1 | b1 | 5 | b3 | 10 |
| a1 | b2 | 6 | b2 | 7 |
| a1 | b2 | 6 | b3 | 10 |
| a2 | b3 | 8 | b3 | 10 |

等值连接：$R \mathop{\bowtie}\limits_{R.B = S.B}S$

| A | R.B | C | S.B | E |
| --- | --- | --- | --- | --- |
| a1 | b1 | 5 | b1 | 3 |
| a1 | b2 | 6 | b2 | 7 |
| a2 | b3 | 8 | b3 | 10 |
| a2 | b3 | 8 | b3 | 2 |

自然连接：$R \bowtie S$

| A | B | C | E |
| --- | --- | --- | --- |
| a1 | b1 | 5 | 3 |
| a1 | b2 | 6 | 7 |
| a2 | b3 | 8 | 10 |
| a2 | b3 | 8 | 2 |

外连接

| A | B | C | E |
| --- | --- | --- | --- |
| a1 | b1 | 5 | 3 |
| a1 | b2 | 6 | 7 |
| a2 | b3 | 8 | 10 |
| a2 | b3 | 8 | 2 |
| a2 | b3 | 12 | null |
| null | b5 | null | 2 |

左外连接

| A | B | C | E |
| --- | --- | --- | --- |
| a1 | b1 | 5 | 3 |
| a1 | b2 | 6 | 7 |
| a2 | b3 | 8 | 10 |
| a2 | b3 | 8 | 2 |
| a2 | b3 | 12 | null |

右外连接

| A | B | C | E |
| --- | --- | --- | --- |
| a1 | b1 | 5 | 3 |
| a1 | b2 | 6 | 7 |
| a2 | b3 | 8 | 10 |
| a2 | b3 | 8 | 2 |
| null | b5 | null | 2 |

### 除 Division

除的运算符为 $\div$

假设有两个关系 R(X, Y)，S(Y, Z)，除运算可以得到一个新的关系 P(X)，代表 R 关系元组 X 中分量 x 的象集（就是 x 可以组合成多少种列）在 S 中的元组 X 中被包含的集合

最后除法的商的属性一定比被除的关系的属性少

<br />

举个例子：

关系 R

| A | B | C |
| --- | --- | --- |
| a1 | b1 | c2 |
| a2 | b3 | c7 |
| a3 | b4 | c6 |
| a1 | b2 | c3 |
| a4 | b6 | c6 |
| a2 | b2 | c3 |
| a1 | b2 | c1 |

关系 S

| B | C | D |
| --- | --- | --- |
| b1 | c2 | d1 |
| b2 | c1 | d1 |
| b2 | c3 | d2 |

$R \div S$

| A |
| --- |
| a1 |

解释：

1. 首先找到关系 R 与关系 S 中有同样域的列，也就是 B 与 C
2. 其次我们要找到关系 R 中 A 列所有取值的象集
3. 当 A 取 a1 时，象集为 {[b1, c2], [b2, c3], [b2, c1]}
4. 当 A 取 a2 时，象集为 {[b3, c7], [b2, c3]}
5. 当 A 取 a3 时，象集为 {[b4, c6]}
6. 当 A 取 a4 时，象集为 {[b6, c6]}
7. 关系 S 中，所有 [B, C] 组合为 {[b1, c2], [b2, c1], [b2, c3]}，只有 A 取 a1 时才完全包含了这一组合
8. 所以最后除的结果是 a1

## 关系演算（理论）

关系演算是以数理逻辑中的谓词演算为基础

关系演算主要可以分为两个部分：**元组关系演算**（以 “行” 为演算单位）与**域关系演算**（以 “表格” 为演算单位）

### 元组关系演算语言 Alpha

元组关系演算以元组变量作为谓词变量的基本对象

主要包含 GET、PUT、HOLD、UPDATE、DELETE、DROP 6 条操作语句

语句的基本格式为：**操作语句 工作空间名(表达式):操作条件**

- 表达式用于说明要查询的结果，它可以是关系名或属性名
- 操作条件是一个逻辑表达式，说明查询结果要满足的条件（可以为空）
- 除此之外，还能在基础格式之上添加排序要求、定额要求等

#### GET 检索操作

一、简单检索（不带条件）

例子：查询所有被选修的课程号码

```sql
GET W(SC.Cno)
```

说明：

- W 为工作空间名
- SC.Cno 是表达式，表示想要查询的结果，在这个例子中是 SC 表中的 Cno 属性
- 操作条件为空，表示不带条件的检索

<br />

二、限定检索（带条件）

例子：查询信息系（IS）中年龄小于 20 的学生的学号

```sql
GET W(Student.Sno):Student.Sdept = ‘IS’ $\wedge$ Student.Sage < 20
```

说明：

- W 是工作空间名
- Student.Sno 是表达式，表示想要查询的是学生表中的学号
- 冒号后面的是操作条件，在这个例子中表示学生是信息系且年龄小于 20 的学生

<br />

三、带排序的检索

例子：查询计算机科学系（CS）中的学生学号、年龄，结果按照年龄降序排序

```sql
GET W(Student.Sno, Student.Sage):Student.Sdept = ‘CS’ DOWN Student.Sage
```

说明：

- Student.Sno, Student.Sage 表示要查询的是学生表中的学号以及年龄
- 冒号后面空格前的部分表示我们需要筛选的学生科系要是 CS
- DOWN 表示降序，DOWN 后面的 Student.Sage 表示要对学生年龄降序
- UP 则表示升序

<br />

四、指定返回元组的个数

例子：取出一个信息系学生（IS）的学号

```sql
GET W(1)(Student.Sno):Student.Sdept = ‘IS’
```

说明：

- W 后面的第一个括号，表示要取出的元组个数，在这个例子中是一个
- 其他的则遵循之前的规则

<br />

五、用元组变量的检索

元组变量可以用来替代关系本身的名称，一个关系可以设置多个元组变量，元组变量主要有两方面用途：

- 简化关系名：如果关系名字很长，可以使用元组变量替代
- 操作条件中使用的**量词必须使用元组变量**

注意事项：

- ALPHA 语言中使用 **RANGE** 来定义元组变量
- **量词一般用于两个以上表的比对**

例子：查询信息系（IS）学生的名字

```sql
RANGE Student X

GET W(X.Sname):X.Sname = ‘IS’
```

说明：

- 与上面例子四不同的是，我们首先用 RANGE 语句以 X 替代了 Student，此时 X 相当于一个 Student 的别称

<br />

六、使用存在量词检索

存在量词  existential quantifier，符号为 $\exists$，其含义为“至少有一个，存在”

例子：【两个表的查询】查询选选修了 2 号课程的学生姓名

```sql
RANGE SC X

GET W(Student.Sname):$\exists X$(X.Sno = Student.Sno $\wedge$ X.Cno = ‘2’)
```

说明：

- 首先我们先将课程表 SC 使用 X 替代
- 其次，我们对 X 使用存在量词，判断同时存在 SC 表与 Student 表中的 Sno 学号且选修了 2 号课程的学生

<br />

例子：【三个表的查询】查询至少选修一门其先行课为 6 号课程的学生名字

```sql
RANGE Cource CX

RANGE SC SCX

GET W(Student.Sname):$\exists SCX$(SCX.Sno = Student.Sno $\wedge$ CX.Cno = SCX.Sno $\wedge$ CX.Pcno = ‘6’)
```

<br />

七、使用全称量词检索

全称量词 Generality quantifier，符号为 $\forall$，其含义为“所有的”

例子：查询不选一号课程的学生姓名

```sql
RANGE SC SCX

GET W(Student.Sname): $\forall$ SCX(SCX.Sno $\neq$ Student.Sno $\vee$ SCX.Cno $\neq$ ‘1’)
```

说明：

- 因为我们需要查找的是“所有”符合条件的学生姓名，所以需要使用全称量词

<br />

八、两种量词一起检索

例子：查询选修了全部课程的学生姓名

```sql
RANGE Course CX

RANGE SC SCX

GET W(Student.Sname): $\forall$ CX $\exists$ SCX(SCX.Sno = Student.Sno $\wedge$ SCX.Cno = CX.Cno)
```

<br />

九、使用蕴含的检索

蕴含 Implication，符号为 $\Rightarrow$，其含义为“从结论 A 能够推导出结论 B”

<br />

十、聚集函数

聚集函数用于使用查询语言时的简单计算，常见的有 COUNT, TOTAL, MAX, MIN, AVG

#### UPDATE 更新操作

一、修改操作

修改操作使用 MOVE 实现，步骤为：

1. 首先用 HOLD 将修改的元组从数据库读到工作空间中
2. 使用 MOVE 修改工作空间中元组的属性
3. 最后使用 UPDATE 将修改后的元组送回数据库

HOLD 与 GET 都能将数据从数据库读到工作区，但是**只有 HOLD 语句能够控制并发**

**HOLD 语句读取的数据将会被加上锁**

例子：将学号为 12345 的学生从计算机系 CS 转到信息系 IS

```sql
HOLD W(Student.Sno, Student.Sdept): Student.Sno = ‘12345’

MOVE ‘IS’ TO W.Sdept

UPDATE W
```

说明：

- 首先使用 HOLD 给数据加锁并读到工作空间
- 用 MOVE 给**工作空间的数据**设置新的系
- 最后使用 UPDATE 将修改后的数据写入数据库
- 如果修改操作涉及到两个关系，需要执行两次 HOLD-MOVE-UPDATE
- 不允许修改关系主码，如果需要修改需要删除该元组后重新添加

<br />

二、插入操作

插入操作使用 PUT 语句实现，步骤为：

1. 使用宿主语言在空间中建立新元组
2. 用 PUT 语句将元组存入指定的关系中

PUT 语句只对一个关系操作，所以表达式必须为单个关系

例子：新增一个“计算机组织”课程，课程有 2 学分，课程号为 8，先行课为 6 号课程

```sql
MOVE ‘8’ TO W.Cno

MOVE ‘计算机组织’ TO W.Cname

MOVE ‘6’ TO W.Cpno

MOVE ‘2’ TO W.Ccredit

PUT W(Course)
```

<br />

三、删除

删除操作使用 DELETE 语句实现，步骤为：

1. 用 HOLD 将要删除的元组读到工作区中
2. 使用 DELETE 语句删除该元组

例子：删除学号为 12345 的学生

```sql
HOLD W(Student): Student.Sno = ‘12345’

DELETE W
```

例子：删除所有学生

```sql
HOLD W(Student)

DELETE W
```

【注意】为了保证关系之间的参照完整性，删除一个关系中的元组时需要删除所有有参照关系的元组